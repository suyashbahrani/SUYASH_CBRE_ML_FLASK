# -*- coding: utf-8 -*-
"""CBRE_ML.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cVQJY8Upgz7k2E6uaUA_lMR7tVft3nvL
"""

# Import necessary libraries
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
import joblib

# Assuming your data is stored in a DataFrame named 'df'
# Replace 'your_data.csv' with the actual file path if loading from a CSV file

# Load the data
df = pd.read_excel('Sample_Data_80K_V5.xlsx')

broker_id_mapping = {firm: id for id, firm in enumerate(df['Broker_Firm_Name'].unique(), start=201)}
# Map the Broker ID to each row in the DataFrame
df['Broker_ID'] = df['Broker_Firm_Name'].map(broker_id_mapping)

import numpy as np

na_values = df['Difference (in days)'].isna()

# Find infinite values
inf_values = ~np.isfinite(df['Difference (in days)'])

# Combine both NA and infinite values
non_finite_values = df[na_values | inf_values]

# Count the number of NA or infinite values
num_non_finite_values = non_finite_values.shape[0]

# Convert Commission_Rate from percentage to decimal
# df['Commission_Rate'] = df['Commission_Rate'] / 100

df['Date_of_Purchase'] = pd.to_datetime(df['Date_of_Purchase'])
df['Date_of_Closing'] = pd.to_datetime(df['Date_of_Closing'])

# Calculate the difference in days
df['Difference (in days)'] = (df['Date_of_Closing'] - df['Date_of_Purchase']).dt.days

# Identify rows with negative differences
negative_difference = df['Difference (in days)'] < 0

# Swap 'Date_of_Purchase' and 'Date_of_Closing' where necessary
temp_dates = df.loc[negative_difference, 'Date_of_Purchase'].copy()
df.loc[negative_difference, 'Date_of_Purchase'] = df.loc[negative_difference, 'Date_of_Closing']
df.loc[negative_difference, 'Date_of_Closing'] = temp_dates

# Recalculate the difference in days after potential swapping
df['Difference (in days)'] = (df['Date_of_Closing'] - df['Date_of_Purchase']).dt.days




# Create a new column 'Price_with_Commission'
df['Price_with_Commission'] = df['Price_in_USD'] * (1 + df['Commission_Rate']/100)


import pandas as pd

# Sample data
data = {
    'Area': ['Melbourne', 'Tokyo', 'Cairo', 'Manila', 'Brussels', 'Nairobi',
       'Miami', 'Johannesburg', 'San Francisco', 'New Delhi',
       'Buenos Aires', 'Madrid', 'Auckland', 'Athens', 'Bangkok',
       'Singapore', 'Shanghai', 'Dubai', 'Port Moresby', 'Sydney',
       'Sao Paulo', 'Ottawa', 'Seoul', 'Edmonton', 'Rio de Janeiro',
       'Paris', 'Toronto', 'London', 'Berlin', 'New York City',
       'Ho Chi Minh City', 'Lima', 'Mexico City', 'Lagos', 'Rome',
       'Kuala Lumpur', 'Santiago']
}


# Mapping dictionary based on the provided regions and countries
mapping = {
    'New York City': ('North America', 'USA'),
    'Rio de Janeiro': ('South America', 'Brazil'),
    'Paris': ('Europe', 'France'),
    'Tokyo': ('Asia', 'Japan'),
    'Toronto': ('North America', 'Canada'),
    'Buenos Aires': ('South America', 'Argentina'),
    'Johannesburg': ('Africa', 'South Africa'),
    'Shanghai': ('Asia', 'China'),
    'Dubai': ('Middle East', 'UAE'),
    'Sydney': ('Oceania', 'Australia'),
    'San Francisco': ('North America', 'USA'),
    'Santiago': ('South America', 'Chile'),
    'Berlin': ('Europe', 'Germany'),
    'Seoul': ('Asia', 'South Korea'),
    'Ottawa': ('North America', 'Canada'),
    'Miami': ('North America', 'USA'),
    'New Delhi': ('Asia', 'India'),
    'Rome': ('Europe', 'Italy'),
    'Melbourne': ('Oceania', 'Australia'),
    'Sao Paulo': ('South America', 'Brazil'),
    'Singapore': ('Asia', 'Singapore'),
    'Nairobi': ('Africa', 'Kenya'),
    'Kuala Lumpur': ('Asia', 'Malaysia'),
    'Madrid': ('Europe', 'Spain'),
    'Mexico City': ('North America', 'Mexico'),
    'London': ('Europe', 'United Kingdom'),
    'Cairo': ('Africa', 'Egypt'),
    'Auckland': ('Oceania', 'New Zealand'),
    'Lima': ('South America', 'Peru'),
    'Manila': ('Asia', 'Philippines'),
    'Edmonton': ('North America', 'Canada'),
    'Brussels': ('Europe', 'Belgium'),
    'Ho Chi Minh City': ('Asia', 'Vietnam'),
    'Lagos': ('Africa', 'Nigeria'),
    'Port Moresby': ('Oceania', 'Papua New Guinea'),
    'Buenos Aires': ('South America', 'Argentina'),
    'Athens': ('Europe', 'Greece'),
    'Bangkok': ('Asia', 'Thailand'),
}

# Apply the mapping to create Region and Country columns
df = df.assign(Region=df['Area'].map(mapping).apply(lambda x: x[0] if x else 'Unknown'),
               Country=df['Area'].map(mapping).apply(lambda x: x[1] if x else 'Unknown'))

df = df[['Broker_ID', 'Broker_Firm_Name', 'Category', 'Region' , 'Country', 'Area', 'Zipcode', 'Property_Type', 'Property_Size',
         'Transaction_Type', 'Price_in_USD', 'Commission_Rate', 'Price_with_Commission','Date_of_Purchase', 'Date_of_Closing', 'Difference (in days)',
         'Feedback_Score', 'Feedback_Comments', 'Payment_Terms', 'Warranty_Period']]

df['Broker_Firm_Name'] = df['Broker_Firm_Name'].astype(str)
df['Category'] = df['Category'].astype(str)
df['Region'] = df['Region'].astype(str)
df['Country'] = df['Country'].astype(str)
df['Area'] = df['Area'].astype(str)
df['Zipcode'] = df['Zipcode'].astype(str)
df['Property_Type'] = df['Property_Type'].astype(str)
df['Transaction_Type'] = df['Transaction_Type'].astype(str)
df['Price_in_USD'] = df['Price_in_USD'].astype(float)
df['Commission_Rate'] = df['Commission_Rate'].astype(float)
df['Price_with_Commission'] = df['Price_with_Commission'].astype(float)
df['Date_of_Purchase'] = pd.to_datetime(df['Date_of_Purchase'])
df['Date_of_Closing'] = pd.to_datetime(df['Date_of_Closing'])
df['Difference (in days)'] = df['Difference (in days)'].astype(int)
df['Feedback_Score'] = df['Feedback_Score'].astype(float)
df['Feedback_Comments'] = df['Feedback_Comments'].astype(str)
df['Payment_Terms'] = df['Payment_Terms'].astype(str)
df['Warranty_Period'] = df['Warranty_Period'].astype(str)

df['Price_in_USD'] = df['Price_in_USD'] / 1e6  # Divide by 1 million to convert to millions

# Optionally, you can round the values to a certain number of decimal places
# For example, rounding to 2 decimal places:
df['Price_in_USD'] = df['Price_in_USD']


df['Price_with_Commission'] = df['Price_with_Commission'] / 1e6  # Divide by 1 million to convert to millions

# Optionally, you can round the values to a certain number of decimal places
# For example, rounding to 2 decimal places:
df['Price_with_Commission'] = df['Price_with_Commission']

df['Property_Size'] = df['Property_Size'].str.extract('(\d+)').astype(float)

# Select relevant features and target variable
features = ['Broker_Firm_Name',	'Category',	'Region',	'Country',	'Area', 'Property_Type','Property_Size','Transaction_Type', 'Feedback_Score']
target = 'Price_in_USD'

# Extract features and target variable
X = df[features]
y = df[target]

numerical_features = ['Property_Size', 'Commission_Rate', 'Difference (in days)', 'Feedback_Score']
categorical_features = ['Property_Type', 'Transaction_Type', 'Region', 'Country', 'Area']

# Extract features and target variable
X = df[numerical_features + categorical_features]
y = df['Price_in_USD']

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Create preprocessing pipelines for numerical and categorical features
numerical_transformer = StandardScaler()
categorical_transformer = OneHotEncoder(handle_unknown='ignore')

# Combine the transformers using ColumnTransformer
preprocessor = ColumnTransformer(
    transformers=[
        ('num', numerical_transformer, numerical_features),
        ('cat', categorical_transformer, categorical_features)
    ])

# Create a pipeline with preprocessing and linear regression model
model = Pipeline(steps=[('preprocessor', preprocessor),
                        ('regressor', LinearRegression())])

# Train the model
model.fit(X_train, y_train)

# Make predictions on the test set
predictions = model.predict(X_test)

joblib.dump(model, 'model2.pkl')

# Evaluate the model
mse = mean_squared_error(y_test, predictions)
print(f'Mean Squared Error: {mse}')

# View the coefficients and intercept
# Note: Accessing coefficients and intercept might be tricky due to one-hot encoding
# It's recommended to use feature names to interpret coefficients for categorical variables
print('Intercept:', model.named_steps['regressor'].intercept_)

from sklearn.metrics import r2_score, mean_absolute_error

# Additional regression metrics
r2 = r2_score(y_test, predictions)
mae = mean_absolute_error(y_test, predictions)

print(f'R-squared: {r2}')
print(f'Mean Absolute Error: {mae}')

from sklearn.model_selection import cross_val_score
cv_mse = -cross_val_score(model, X, y, scoring='neg_mean_squared_error', cv=5)
print(f'Cross-Validated MSE: {cv_mse.mean()}')

from sklearn.metrics import mean_absolute_error
mae = mean_absolute_error(y_test, predictions)

print("Mean Absolute Error:", mae)

# Calculate the price difference between actual and predicted values
price_difference = (y_test * 1e6) - (predictions * 1e6)

# Create a DataFrame to display the actual, predicted, and difference values
result_df = pd.DataFrame({'Actual': y_test * 1e6, 'Predicted': predictions * 1e6, 'Price Difference': price_difference})

# Filter rows where the absolute price difference is less than 5%
threshold_percentage = 5
filtered_result_df = result_df[abs(result_df['Price Difference'] / result_df['Actual'] * 100) < threshold_percentage]

# Display the filtered DataFrame
print(filtered_result_df)

import pandas as pd
import ipywidgets as widgets
from IPython.display import display

# Function to make predictions using the trained model
def predict_price(property_size, commission_rate, difference_days, feedback_score,
                  property_type, transaction_type, region, country, area):
    # Create a DataFrame with the input parameters
    input_data = pd.DataFrame({
        'Property_Size': [property_size],
        'Commission_Rate': [commission_rate],
        'Difference (in days)': [difference_days],
        'Feedback_Score': [feedback_score],
        'Property_Type': [property_type],
        'Transaction_Type': [transaction_type],
        'Region': [region],
        'Country': [country],
        'Area': [area]
    })

    # Use the preprocessor to transform the input data
    input_data_transformed = model.named_steps['preprocessor'].transform(input_data)

    # Make predictions on the transformed input data
    prediction = model.named_steps['regressor'].predict(input_data_transformed)

    return (prediction[0], prediction[0] * 1.1)

def predict_and_get_brokers(property_size, commission_rate, difference_days, feedback_score,
                            property_type, transaction_type, region, country, area, threshold=0.5):
    # Calculate the predicted price and max price
    predicted_price, max_price = predict_price(property_size, commission_rate, difference_days, feedback_score,
                                               property_type, transaction_type, region, country, area)

    # Filter brokers based on the specified conditions
    matched_brokers = df[
        (df['Region'] == region) &
        (df['Transaction_Type'] == transaction_type) &
        (df['Property_Type'] == property_type) 
        # &
        #(df['Property_Size'].between(property_size * (1 - threshold), property_size * (1 + threshold))) 
        # &
        # (df['Feedback_Score'].between(feedback_score * (1 - threshold), feedback_score * (1 + threshold))) &
        # (df['Commission_Rate'].between(commission_rate * (1 - threshold), commission_rate * (1 + threshold))) &
        # (df['Difference (in days)'].between(difference_days * (1 - threshold), difference_days * (1 + threshold)))
    ]

    
    return matched_brokers
    
# UI components
property_size_slider = widgets.IntSlider(min=10000, max=100000, step=1000, value=32000, description='Property Size')
commission_rate_slider = widgets.FloatSlider(min=1.0, max=5.0, step=0.1, value=3.49, description='Commission Rate')
difference_days_slider = widgets.IntSlider(min=1, max=50, step=1, value=25, description='Difference (in days)')
feedback_score_slider = widgets.IntSlider(min=1, max=5, step=1, value=4, description='Feedback Score')
property_type_dropdown = widgets.Dropdown(options=['Commercial Center', 'Residential','Industrial','Landscaped Grounds', 'Corporate Office', 'Resort Complex',
       'Industrial Complex', 'Commercial Complex', 'Office Building',
       'Office Space', 'Office Park', 'Shopping Mall', 'Corporate Tower',
       'Commercial Park', 'Commercial Tower', 'Shopping Center'], value='Commercial Center', description='Property Type')
transaction_type_dropdown = widgets.Dropdown(options=['Lease', 'Sale'], value='Lease', description='Transaction Type')
region_text = widgets.Text(value='South America', description='Region')
country_text = widgets.Text(value='Chile', description='Country')
area_text = widgets.Text(value='Santiago', description='Area')

# Button to trigger predictions
predict_button = widgets.Button(description='Predict')

# Output widget to display predictions
output = widgets.Output()

predicted_Data_of_Brokers = None

# Function to handle button click and trigger predictions
def on_predict_button_click(b):
    global predicted_Data_of_Brokers
    with output:
        output.clear_output()
        predicted_price = predict_price(
            property_size_slider.value, commission_rate_slider.value,
            difference_days_slider.value, feedback_score_slider.value,
            property_type_dropdown.value, transaction_type_dropdown.value,
            region_text.value, country_text.value, area_text.value
        )
        predicted_brokers = predict_and_get_brokers(
            property_size=property_size_slider.value,
            commission_rate=commission_rate_slider.value,
            difference_days=difference_days_slider.value,
            feedback_score=feedback_score_slider.value,
            property_type=property_type_dropdown.value,
            transaction_type=transaction_type_dropdown.value,
            region=region_text.value,
            country=country_text.value,
            area=area_text.value
        )
        predicted_Data_of_Brokers = predicted_brokers

        print(f'Predicted Price: {np.round(predicted_price[0]*1e6,2)}')




# Attach the click event to the button
predict_button.on_click(on_predict_button_click)

# Arrange UI components
ui = widgets.VBox([
    property_size_slider, commission_rate_slider, difference_days_slider,
    feedback_score_slider, property_type_dropdown, transaction_type_dropdown,
    region_text, country_text, area_text, predict_button, output
])

# Display the UI
display(ui)

# # Example usage:
# property_size = 32000
# commission_rate = 3.49
# difference_days = 25
# feedback_score = 4
# property_type = 'Commercial Center'
# transaction_type = 'Lease'
# region = 'South America'
# country = 'Chile'
# area = 'Santiago'

# # Make a prediction using the provided parameters
# predicted_price = predict_price(property_size, commission_rate, difference_days, feedback_score,
#                                 property_type, transaction_type, region, country, area)

# print(f'Predicted Price: {predicted_price}')



# Function to get input from the user
def get_input():
    property_size = int(input('Enter Property Size: '))
    commission_rate = float(input('Enter Commission Rate: '))
    difference_days = int(input('Enter Difference (in days): '))
    feedback_score = int(input('Enter Feedback Score: '))
    property_type = input('Enter Property Type: ')
    transaction_type = input('Enter Transaction Type (Lease/Sale): ')
    region = input('Enter Region: ')
    country = input('Enter Country: ')
    area = input('Enter Area: ')
    return property_size, commission_rate, difference_days, feedback_score, property_type, transaction_type, region, country, area

# Main function to run the application
def main():
    while True:
        print("\n--- Property Price Prediction ---")
        property_size, commission_rate, difference_days, feedback_score, property_type, transaction_type, region, country, area = get_input()
        predicted_price = predict_price(property_size, commission_rate, difference_days, feedback_score,
                                         property_type, transaction_type, region, country, area)
        print(f'Predicted Price: {np.round(predicted_price*1e6, 2)}')
        choice = input("Do you want to predict another property price? (yes/no): ")
        if choice.lower() != 'yes':
            break

if __name__ == "__main__":
    main()
